////////////////////////////////////////////////////////////////////////////////
//
//  YOUR QUILL
//
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <tachyon/event/Event.hpp>
#include <vector>
#include <atomic>
//#include <tbb/spin_rw_mutex.h> // if we need it

namespace yq::tachyon {
    class EventProducer {
    public:

        void    subscribe(EventSocket&);
        void    unsubscribe(EventSocket&);
        void    unsubscribe_all();

        virtual std::string_view    name() const;
        virtual std::string_view    description() const;
        
        //! Total number of events generated by this producer
        uint64_t    events_generated() const;

    protected:

        void                    publish(EventPtr);

        template <SomeEvent E>
        E&                      publish(E* ep, ref_t)
        {
            assert(ep);
            publish(ep);
            return *ep;
        }

        template <SomeEvent E>
        E&                      publish(E* ep, reference_t)
        {
            assert(ep);
            publish(ep);
            return *ep;
        }

        template <SomeEvent E>
        E*                      publish(E* ep, pointer_t)
        {
            assert(ep);
            publish(ep);
            return ep;
        }

        EventProducer();
        ~EventProducer();
    
    private:
        
        friend class EventSocket;
        friend class EventManager;

        struct Thread;
        static Thread&              thread();

        //mutable tbb::spin_rw_mutex  m_mutex;
        std::vector<EventSocket*>   m_sockets;
        std::atomic<uint64_t>       m_count{0};
        
        bool    _has(EventSocket*) const;
        void    _subscribe(EventSocket*);
        void    _unsubscribe(EventSocket*);
    };
}
