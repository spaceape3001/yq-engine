////////////////////////////////////////////////////////////////////////////////
//
//  YOUR QUILL
//
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <yq/core/Ref.hpp>
#include <yq/core/Cleanup.hpp>
#include <vulkan/vulkan_core.h>
#include <vk_mem_alloc.h>
#include <tbb/spin_rw_mutex.h>
#include <yt/keywords.hpp>
#include <yv/ViQueueType.hpp>
#include <yv/typedef/vi_queue_id.hpp>
#include <yv/typedef/vi_queue_tasker.hpp>
#include <map>

namespace yq::tachyon {
    struct VulqanCreateInfo;
    
    /*

        On observation that *NOTHING* in the vkCreateDevice() call relies on 
        surfaces (ie, the windows), the visualizer is going to be split.  
        
        ViDevice will be the vulkan logical device, which is tied to a GPU, 
        likely owned by the VulqanManager.
        
        Visualizer will continue to bind the surface to rendering.
    
    */
    
    class ViDevice : public RefCount {
    public:
    
        /* 
            In order to remove the surface dependency for creating a vulkan logical 
            device, we need to assume that the present queue is available on the 
            graphics queue.  While a generally safe assumption given the current
            GPUs available, it might not be true.  Should we find a card/situation, 
            we'll figure out a way to enumerate that queue family into this list w/o 
            requiring the surface/present-queue-check.
            
            *IF* compute is specified *AND* there is a non-graphics compute queue, 
            it will be used.
            
            *IF* video decode is specifed & found, it'll be used.
            
            *IF* video encode is specifed & found, it'll be used.

            *IF* a transfer queue is found that *ISN'T* graphics, compute, video encode/decode, or optical, 
            that will be used.
            
            Eventually, we'll get the queue stuff spot on, until then, muddle away!
        */

        ViDevice(VkPhysicalDevice, const VulqanCreateInfo&);
        ~ViDevice();
        
        void                cleanup(cleanup_fn&&);
        void                cleanup(sweep_k);
        
        VkDevice            device() const { return m_device; }
        void                destroy();

        std::string_view    gpu_name() const;

            //! Returns the type of the GPU/physical device
        VkPhysicalDeviceType            gpu_type() const;
        
        std::error_code     init(VkPhysicalDevice, const VulqanCreateInfo&);
        
        bool                valid() const;
        
        VmaAllocator        allocator() const { return m_allocator; }
        
        bool                is_queue_compute(ViQueueFamilyID) const;
        bool                is_queue_graphic(ViQueueFamilyID) const;
        bool                is_queue_optical(ViQueueFamilyID) const;
        bool                is_queue_present_supported(ViQueueFamilyID, VkSurfaceKHR) const;
        bool                is_queue_sparse_binding(ViQueueFamilyID familyIdx) const;
        bool                is_queue_transfer(ViQueueFamilyID familyIdx) const;
        bool                is_queue_video_decode(ViQueueFamilyID familyIdx) const;
        bool                is_queue_video_encode(ViQueueFamilyID familyIdx) const;

        uint32_t            max_memory_allocation_count() const;
        uint32_t            max_push_constants_size() const;
        float               max_sampler_anisotropy() const;
        uint32_t            max_viewports() const;

        //! TRUE if multiple views of the render-pass is enabled
        bool                            multiview_enabled() const;
        
        /*! \brief Maximum index value
        
            KHR's description:
            maxMultiviewInstanceIndex is the maximum valid value of instance index allowed to be generated by a 
            drawing command recorded within a subpass of a multiview render pass instance.            
        */
        uint32_t                        multiview_max_instance_index() const;
        
        /*! Maximumum number of views
        
            KHR's description:
            maxMultiviewViewCount is one greater than the maximum view index that can be used in a subpass.
        */
        uint32_t                        multiview_max_view_count() const;

        VkPhysicalDevice    physical() const { return m_physical; }

        VkQueue             queue(const ViQueueID&) const;
        VkQueue             queue(ViQueueFamilyID familyIdx, uint32_t subIdx) const;

        uint32_t            queue_count(ViQueueFamilyID familyIdx) const;

        uint32_t            queue_family_count() const;
        VkQueueFlags        queue_family_flags(ViQueueFamilyID familyIdx) const;
        
        //! Queue family for type (note, UINT32_MAX is invalid)
        ViQueueFamilyID     queue_family(ViQueueType) const;
        
        
        
        std::error_code     queue_task(ViQueueID, queue_tasker_fn&&);
        std::error_code     queue_task(ViQueueID, uint64_t timeout, queue_tasker_fn&&);

        ViQueueTaskerPtr    queue_tasker(ViQueueID);
        
        bool                is_queue_valid(ViQueueID) const;
        
        //! Recommended Graphics Queue for tasks that aren't direct-display-related
        ViQueueID           graphics_queue(headless_k) const;
        ViQueueID           graphics_queue(uint32_t viewerId) const;
        
        std::error_code     wait_idle() const;
        
    private:
        struct QueueFamily;
    
        using mutex_t   = tbb::spin_rw_mutex;
        using lock_t    = mutex_t::scoped_lock;
    
        VmaAllocator                            m_allocator                 = nullptr;
        Cleanup                                 m_cleanup;
        VkDevice                                m_device                    = nullptr;
        VkPhysicalDeviceFeatures                m_gpuFeatures;
        VkPhysicalDeviceMemoryProperties        m_gpuMemory;
        std::string                             m_gpuName;
        VkPhysicalDeviceProperties              m_gpuProperties;
        VkPhysicalDevice                        m_physical                  = nullptr;
        std::vector<QueueFamily>                m_queueFamilies;
        std::map<ViQueueType,ViQueueFamilyID>   m_queueType2Family;
        std::map<ViQueueID, ViQueueTaskerPtr>   m_taskers;
        mutable mutex_t                         m_taskerMutex;

        struct {
            bool        enabled             = false;
            // KHR -- One greater than the maximum view index that can be used in a subpass.
            uint32_t    maxViewCount        = 0;
            // KHR -- maximum valid value of instance index allowed to be generated by a drawing command recorded within a subpass of a multiview render pass instance.
            uint32_t    maxInstanceIndex    = 0;
        }                                   m_multiview;
        
        const QueueFamily*  _family(ViQueueFamilyID) const;
        QueueFamily*        _family(ViQueueFamilyID);
        
        
        // NOTE -- present queue will remain in the visualizer as that's surface dependent... the rest are not
        
        void                _kill();
        std::error_code     _init(VkPhysicalDevice, const VulqanCreateInfo&);
    };
}

