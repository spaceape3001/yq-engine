////////////////////////////////////////////////////////////////////////////////
//
//  YOUR QUILL
//
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <yq/core/Ref.hpp>
#include <yq/core/Cleanup.hpp>
#include <vulkan/vulkan_core.h>
#include <vk_mem_alloc.h>
#include <tbb/spin_rw_mutex.h>
#include <yv/ViQueueType.hpp>
#include <map>

namespace yq::tachyon {
    struct VulqanCreateInfo;
    
    struct ViQueueFamilyID {
        uint32_t    index      = UINT32_MAX;
        auto    operator<=>(const ViQueueFamilyID&) const = default;
        bool    valid() const { return index != UINT32_MAX; }
        bool    invalid() const { return index == UINT32_MAX; }
    };

    struct ViQueueID {  // TBH... 16 or even 8-bits might be enough here... spec is 32-bits though
        ViQueueFamilyID     family;
        uint32_t            sub     = 0;
        
        auto    operator<=>(const ViQueueID&) const = default;
    };
    

    /*

        On observation that *NOTHING* in the vkCreateDevice() call relies on 
        surfaces (ie, the windows), the visualizer is going to be split.  
        
        ViDevice will be the vulkan logical device, which is tied to a GPU, 
        likely owned by the VulqanManager.
        
        Visualizer will continue to bind the surface to rendering.
    
    */
    
    class ViDevice : public RefCount {
    public:
    
        /* 
            In order to remove the surface dependency for creating a vulkan logical 
            device, we need to assume that the present queue is available on the 
            graphics queue.  While a generally safe assumption given the current
            GPUs available, it might not be true.  Should we find a card/situation, 
            we'll figure out a way to enumerate that queue family into this list w/o 
            requiring the surface/present-queue-check.
            
            *IF* compute is specified *AND* there is a non-graphics compute queue, 
            it will be used.
            
            *IF* video decode is specifed & found, it'll be used.
            
            *IF* video encode is specifed & found, it'll be used.

            *IF* a transfer queue is found that *ISN'T* graphics, compute, video encode/decode, or optical, 
            that will be used.
            
            Eventually, we'll get the queue stuff spot on, until then, muddle away!
        */

        ViDevice(VkPhysicalDevice, const VulqanCreateInfo&);
        ~ViDevice();
        
        void        cleanup();
        
        std::error_code     init(VkPhysicalDevice, const VulqanCreateInfo&);
        
        bool                valid() const;
        
        bool                is_queue_compute(ViQueueFamilyID) const;
        bool                is_queue_graphic(ViQueueFamilyID) const;
        bool                is_queue_optical(ViQueueFamilyID) const;
        bool                is_queue_sparse_binding(ViQueueFamilyID familyIdx) const;
        bool                is_queue_transfer(ViQueueFamilyID familyIdx) const;
        bool                is_queue_video_decode(ViQueueFamilyID familyIdx) const;
        bool                is_queue_video_encode(ViQueueFamilyID familyIdx) const;

        VkQueue             queue(const ViQueueID&) const;
        VkQueue             queue(ViQueueFamilyID familyIdx, uint32_t subIdx) const;

        uint32_t            queue_count(ViQueueFamilyID familyIdx) const;

        uint32_t            queue_family_count() const;
        VkQueueFlags        queue_family_flags(ViQueueFamilyID familyIdx) const;
        
        //! Queue family for type (note, UINT32_MAX is invalid)
        ViQueueFamilyID     queue_family(ViQueueType) const;
        
        std::string_view    gpu_name() const;
        
    private:
        struct QueueFamily;
    
        VmaAllocator                            m_allocator                 = nullptr;
        Cleanup                                 m_cleanup;
        VkDevice                                m_device                    = nullptr;
        std::string                             m_gpuName;
        VkPhysicalDeviceProperties              m_gpuProperties;
        VkPhysicalDevice                        m_physical                  = nullptr;
        std::vector<QueueFamily>                m_queueFamilies;
        std::map<ViQueueType,ViQueueFamilyID>   m_queueType2Family;

        struct {
            bool        enabled             = false;
            // KHR -- One greater than the maximum view index that can be used in a subpass.
            uint32_t    maxViewCount        = 0;
            // KHR -- maximum valid value of instance index allowed to be generated by a drawing command recorded within a subpass of a multiview render pass instance.
            uint32_t    maxInstanceIndex    = 0;
        }                                   m_multiview;
        
        const QueueFamily*  _family(ViQueueFamilyID) const;
        QueueFamily*        _family(ViQueueFamilyID);
        
        
        // NOTE -- present queue will remain in the visualizer as that's surface dependent... the rest are not
        
        void                _kill();
        std::error_code     _init(VkPhysicalDevice, const VulqanCreateInfo&);
    };
}

